import numpy as np
import networkx as nx

from ot.gromov import gromov_wasserstein

# -------------------------------------
# Functions to study blocks
# -------------------------------------
def blocks(A, n, m):
    """
    Reshapes an array of size (..., N*n, M*m) to size (..., N, M, n, m)

    Parameters
    ----------
    A : ndarray
        Input array. The last two dimensions represent a 2D matrix to be divided into blocks.
    n : int
        Number of rows of each block.
    m : int
        Number of columns of each block.

    Returns
    -------
    ndarray
        Array of shape (..., N, M, n, m).
    """
    sz = A.shape

    N = sz[-2] // n
    M = sz[-1] // m

    # Reshape expands the array of size [N*n, M*m] into a 4D array
    # of size [N, n, M, m].
    # As a default, numpy reads A row by row when reshaping and fills
    # in the last dimension of an array. So for any given row, we reshape
    # a row with M*m elements into a block of size [M, m].
    # There are N*n rows, which are then arranged into [N,n] blocks of
    # size [M, m].
    # At the end, we just reorder the indices so that we have an N-by-M
    # array of blocks of size n-by-m.
    B = A.reshape(*sz[:-2], N, n, M, m)
    return np.moveaxis(B, -3, -2)


def sum_blocks(A):
    """
    Compute the sum over the last two dimensions of an array.

    Parameters
    ----------
    A : ndarray
        Input array with at least two dimensions.

    Returns
    -------
    ndarray
        Array with the same shape as `A`, except the last two dimensions are summed out.
    """
    return np.sum(A, axis=(-2, -1))


def is_cyclic_permutation(T, eps=1e-15):
    """
    Check whether a coupling matrix represents a cyclic permutation.

    Parameters
    ----------
    T : ndarray
        Square matrix to test.
    eps : float, optional
        Threshold below which entries are treated as zero. Default is 1e-15.

    Returns
    -------
    bool
        True if `T` corresponds to a cyclic permutation, False otherwise.
    """
    # T can only be a permutation if it has the
    # same number of rows and columns
    n = T.shape[0]
    if T.shape[1] != n:
        return False

    # Filter out small entries
    [r, c] = np.where(T > eps)

    # Check if r has the same number of entries as T
    if len(r) != T.shape[0]:
        return False

    # r and c are a bijection if either r-c or r+c
    # is a constant vector
    diff1 = np.mod(r - c, n)
    diff2 = np.mod(r + c, n)

    if len(np.unique(diff1)) == 1 or len(np.unique(diff2)) == 1:
        return True
    else:
        return False


def cyclic_by_levels(tree, dtype=int):
    """
    Determine if all nodes of a tree at a fixed height are cyclic.

    Parameters
    ----------
    tree : networkx.DiGraph
        Tree generated by `extract_multiscale_info`.
    dtype : type, optional
        Data type of the returned array. Default is `int`.

    Returns
    -------
    ndarray
        Boolean array of shape (height,) indicating whether couplings at each level are cyclic.
    """
    # Find the height of the tree
    dist = nx.shortest_path_length(tree, 0)
    height = max(dist.values())

    # Leaves are not meant to be cyclic, so we skip them
    tree_nodes = [node for node in tree.nodes if tree.degree[node] > 1]

    # Check if the subblocks at each level are cyclic
    level_cyclic = np.zeros(height, dtype=bool)
    for level in range(height):
        # Get nodes in this level
        nodes = [node for node in tree_nodes if dist[node] == level]

        # Evaluate if all nodes are cyclic
        level_cyclic[level] = all([tree.nodes[i]["cyclic"] for i in nodes])

    return level_cyclic.astype(dtype)


def all_cyclic_permutations(tree):
    """
    Check if all non-leaf nodes of a tree are cyclic.

    Parameters
    ----------
    tree : networkx.DiGraph
        Tree generated by `extract_multiscale_info`.

    Returns
    -------
    bool
        True if all non-leaf nodes are cyclic, False otherwise.
    """
    # Check non-leaf nodes only
    non_leaves = [x for x in tree.nodes() if tree.degree(x) > 1]

    for node in non_leaves:
        if not tree.nodes[node]["cyclic"]:
            return False

    # If we come out of the loop, every coupling was cyclic
    return True


def extract_multiscale_info(T, scales1, scales2, eps=1e-15):
    """
    Recursively construct a multiscale representation of a coupling matrix.

    Some matrices have a nested block structure: they have blocks that have
    their own sub-blocks, which also have sub-blocks, and so on. This function
    creates a tree to represent this nested structure.
    Each node represents a certain block of T, and has one child per sub-block.
    The node also has an attribute 'coup', which is the matrix of block sums.
    E.g. if a 6x6 block has 2x2 blocks, 'coup' is a 3x3 matrix.

    Parameters
    ----------
    T : ndarray
        Input matrix.
    scales1 : list of int
        List with the number of blocks that the rows are grouped in
    scales2 : list of int
        List with the number of blocks that the columns are grouped in
    eps : float, optional
        Threshold below which values are ignored. Default is 1e-15.

    Returns
    -------
    networkx.DiGraph
        Directed tree encoding multiscale couplings and cyclicity information.
        Each node includes attributes:
        - 'coup': restriction of T to the block in question
        - 'cyclic': whether the coupling is cyclic
        - 'loc': (row, column) index within its parent block (for child nodes)
        - 'all_cyclic': (root only) whether all non-leaf nodes are cyclic
    """
    # Check that the size of T matches the scales
    assert T.shape[0] == np.prod(
        scales1
    ), "T.shape[0] doesn't match product of elements of scales1"
    assert T.shape[1] == np.prod(
        scales2
    ), "T.shape[1] doesn't match product of elements of scales2"
    assert len(scales1) == len(scales2), "scales1 and scales2 must have the same length"

    # Create a node for this block
    root = nx.DiGraph()
    root.add_node(0)

    if len(scales1) <= 1:
        cyclic = is_cyclic_permutation(T, eps=eps)
        nx.set_node_attributes(root, {0: T}, "coup")
        nx.set_node_attributes(root, {0: cyclic}, "cyclic")
        return root

    # Construct blocks at the highest level and find the sum of the blocks
    sz_x = np.prod(scales1[1:])
    sz_y = np.prod(scales2[1:])
    B = blocks(T, sz_x, sz_y)
    B_sum = sum_blocks(B)

    # Store the compressed coupling in the tree
    # and check if it is a cyclic permutation
    cyclic = is_cyclic_permutation(B_sum, eps=eps)
    nx.set_node_attributes(root, {0: B_sum}, "coup")
    nx.set_node_attributes(root, {0: cyclic}, "cyclic")

    # Find the blocks that have sum larger than eps
    [r, c] = np.where(B_sum > eps)

    # Extract the subblocks of every block
    n_nodes = 1
    for idx in range(len(r)):
        T_sub = B[r[idx], c[idx]]
        sub_tree = extract_multiscale_info(T_sub, scales1[1:], scales2[1:], eps=eps)

        # Add information
        nx.set_node_attributes(sub_tree, {0: (r[idx], c[idx])}, "loc")

        # Add child to root
        # root.add_edge(0, n_nodes)

        # Paste to the root
        n_i = sub_tree.number_of_nodes()
        mapping = {t: t + n_nodes for t in range(n_i)}
        sub_tree = nx.relabel_nodes(sub_tree, mapping)

        # root = nx.compose(root, sub_tree)
        root = nx.union(root, sub_tree)
        root.add_edge(0, n_nodes)

        # update size
        n_nodes += n_i

    # Indicate if all non-leaf nodes have a cyclic permutation
    all_cyclic = all_cyclic_permutations(root)
    nx.set_node_attributes(root, {0: all_cyclic}, "all_cyclic")

    return root


def block_coupling(nb1, nb2, sz1, sz2):
    """
    Computes a GW optimal coupling between cycles of cliques.

    We first compute a GW optimal coupling between regular cycles,
    then inflate every entry of the coupling into a block of size
    (sz1, sz2).

    Parameters
    ----------
    nb1 : int
        Length of first cycle
    nb2 : int
        Length of second cycle
    sz1 : int
        Size of the cliques in the first graph
    sz2 : int
        Size of the cliques in the second graph

    Returns
    -------
    ndarray
        Coupling matrix of size (nb1*sz1, nb2*sz2).
    """
    C1 = nx.cycle_graph(nb1)
    dm1 = nx.floyd_warshall_numpy(C1)
    C2 = nx.cycle_graph(nb2)
    dm2 = nx.floyd_warshall_numpy(C2)
    T0 = gromov_wasserstein(dm1, dm2)

    T = np.repeat(T0, sz1, axis=0)
    T = np.repeat(T, sz2, axis=1)
    T = T / (sz1 * sz2)

    return T
