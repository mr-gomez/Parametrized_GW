import numpy as np
import networkx as nx

from ot.gromov import gromov_wasserstein

# -------------------------------------
# Functions to study blocks
# -------------------------------------
# Extracts n*m blocks from the last two dimensions of the array A.
# Assumes that the number of rows and columns are divisible by n and m
# respectively
def blocks(A, n, m):
    sz = A.shape

    N = sz[-2] // n
    M = sz[-1] // m

    # Reshape expands the array of size [N*n, M*m] into a 4D array
    # of size [N, n, M, m].
    # As a default, numpy reads A row by row when reshaping and fills
    # in the last dimension of an array. So for any given row, we reshape
    # a row with M*m elements into a block of size [M, m].
    # There are N*n rows, which are then arranged into [N,n] blocks of
    # size [M, m].
    # At the end, we just reorder the indices so that we have an N-by-M
    # array of blocks of size n-by-m.
    B = A.reshape(*sz[:-2], N, n, M, m)
    return np.moveaxis(B, -3, -2)


# Just sums the last 2 dimensions of an array
def sum_blocks(A):
    return np.sum(A, axis=(-2, -1))


# Checks if a coupling is a cyclic permutation
# (after filtering for small entries)
def is_cyclic_permutation(T, eps=1e-15):
    # T can only be a permutation if it has the
    # same number of rows and columns
    n = T.shape[0]
    if T.shape[1] != n:
        return False

    # Filter out small entries
    [r, c] = np.where(T > eps)

    # Check if r has the same number of entries as T
    if len(r) != T.shape[0]:
        return False

    # r and c are a bijection if either r-c or r+c
    # is a constant vector
    diff1 = np.mod(r - c, n)
    diff2 = np.mod(r + c, n)

    if len(np.unique(diff1)) == 1 or len(np.unique(diff2)) == 1:
        return True
    else:
        return False


# Checks if the output of extract_multiscale_info comes
# from a coupling that is cyclic at all levels
def cyclic_by_levels(tree, dtype=int):
    # Find the height of the tree
    dist = nx.shortest_path_length(tree, 0)
    height = max(dist.values())

    # Leaves are not meant to be cyclic, so we discard them
    tree_nodes = [node for node in tree.nodes if tree.degree[node] > 1]

    # Check if the subblocks at each level are cyclic
    level_cyclic = np.zeros(height, dtype=bool)
    for level in range(height):
        # Get nodes in this level
        nodes = [node for node in tree_nodes if dist[node] == level]

        # Evaluate if all nodes are cyclic
        level_cyclic[level] = all([tree.nodes[i]["cyclic"] for i in nodes])

    return level_cyclic.astype(dtype)


# Checks if all block matrices are cyclic permutations.
# Takes as input a networkx tree generated by the function
# extract_multiscale_info
def all_cyclic_permutations(tree):
    # Collect all nodes that have descendants.
    # Remember that a child of a node is the sub-coupling induced
    # by a block of the matrix. Hence, for all nodes with children,
    # we want to check if they all are cyclic permutations.
    non_leaves = [x for x in tree.nodes() if tree.out_degree(x) > 0]

    for node in non_leaves:
        if not tree.nodes[node]["cyclic"]:
            return False

    # If we come out of the loop, every coupling was cyclic
    return True


def extract_multiscale_info(T, scales1, scales2, eps=1e-15):
    # Check that the size of T matches the scales
    assert T.shape[0] == np.prod(
        scales1
    ), "T.shape[0] doesn't match product of elements of scales1"
    assert T.shape[1] == np.prod(
        scales2
    ), "T.shape[1] doesn't match product of elements of scales2"
    assert len(scales1) == len(scales2), "scales1 and scales2 must have the same length"

    # Create a node for this block
    root = nx.DiGraph()
    root.add_node(0)

    if len(scales1) <= 1:
        cyclic = is_cyclic_permutation(T, eps=eps)
        nx.set_node_attributes(root, {0: T}, "coup")
        nx.set_node_attributes(root, {0: cyclic}, "cyclic")
        return root

    # Construct blocks at the highest level and find the sum of the blocks
    sz_x = np.prod(scales1[1:])
    sz_y = np.prod(scales2[1:])
    B = blocks(T, sz_x, sz_y)
    B_sum = sum_blocks(B)

    # Store the compressed coupling in the tree
    # and check if it is a cyclic permutation
    cyclic = is_cyclic_permutation(B_sum, eps=eps)
    nx.set_node_attributes(root, {0: B_sum}, "coup")
    nx.set_node_attributes(root, {0: cyclic}, "cyclic")

    # Find the blocks that have sum larger than eps
    [r, c] = np.where(B_sum > eps)

    # Extract the subblocks of every block
    n_nodes = 1
    for idx in range(len(r)):
        T_sub = B[r[idx], c[idx]]
        sub_tree = extract_multiscale_info(T_sub, scales1[1:], scales2[1:], eps=eps)

        # Add information
        nx.set_node_attributes(sub_tree, {0: (r[idx], c[idx])}, "loc")

        # Add child to root
        # root.add_edge(0, n_nodes)

        # Paste to the root
        n_i = sub_tree.number_of_nodes()
        mapping = {t: t + n_nodes for t in range(n_i)}
        sub_tree = nx.relabel_nodes(sub_tree, mapping)

        # root = nx.compose(root, sub_tree)
        root = nx.union(root, sub_tree)
        root.add_edge(0, n_nodes)

        # update size
        n_nodes += n_i

    # Indicate if all non-leaf nodes have a cyclic permutation
    all_cyclic = all_cyclic_permutations(root)
    nx.set_node_attributes(root, {0: all_cyclic}, "all_cyclic")

    return root


# Computes a GW coupling between cycle graphs of sizes nb1, nb2
# Then replaces each entry of the coupling with a block of size (sz1, sz2)
def block_coupling(nb1, nb2, sz1, sz2):
    C1 = nx.cycle_graph(nb1)
    dm1 = nx.floyd_warshall_numpy(C1)
    C2 = nx.cycle_graph(nb2)
    dm2 = nx.floyd_warshall_numpy(C2)
    T0 = gromov_wasserstein(dm1, dm2)

    T = np.repeat(T0, sz1, axis=0)
    T = np.repeat(T, sz2, axis=1)
    T = T / (sz1 * sz2)

    return T
