import numpy as np
from scipy.linalg import expm

# Graph functions
import networkx as nx

# Utilities
import time as time
from utils.utils import display_time

# -------------------------------------
# Heat kernel
# -------------------------------------
def heat_kernel(G, t):
    """
    Compute the heat kernel matrix of a graph.

    Parameters
    ----------
    G : networkx.Graph
        Input graph
    t : float
        Time parameter

    Returns
    -------
    H : numpy.ndarray
        The heat kernel matrix of shape ``(n, n)``, where ``n`` is the
        number of nodes in the graph.
    """
    L = nx.laplacian_matrix(G).todense()
    H = expm(-t * L)

    return H


# -------------------------------------
# Shortest path distance matrices
# -------------------------------------
def shortest_paths_subsets(G, v_start, v_end):
    """
    Matrix of shortest path distances between nodes in two subsets.

    Builds a distance matrix where each element (i, j) is the shortest
    path distance between ``v_start[i]`` and ``v_end[j]``.

    Parameters
    ----------
    G : networkx.Graph
        The input graph.
    v_start : list
        List of source node indices.
    v_end : list
        List of target node indices.

    Returns
    -------
    dm : numpy.ndarray
        A matrix of shape ``(len(v_start), len(v_end))`` where
        ``dm[i, j]`` is the shortest path distance from
        ``v_start[i]`` to ``v_end[j]``.
    """
    n = len(v_start)
    m = len(v_end)
    dm = np.zeros((n, m))

    # Find all shortest paths from each vertex in v_start
    for i, v in enumerate(v_start):
        for j, w in enumerate(v_end):
            dm[i, j] = nx.shortest_path_length(G, source=v, target=w, weight="weight")

    return dm


def all_pairs_shortest_path_weighted(G, weight="weight", progress=0.1):
    """
    Compute all-pairs shortest path distances for a weighted sparse graph.

    This is a wrapper for NetworkX shortest path methods. This just assembles
    the dict obtained from nx.shortest_path_length into a matrix. This is
    faster than nx.floyd_warshall when the graph is sparse.

    Parameters
    ----------
    G : networkx.Graph
        The input weighted graph.
    weight : str, optional
        Edge attribute representing the weight (default is "weight").
    progress : float or None, optional
        Fractional progress interval for printing timing updates.
        Print progress after performing a percentage (between 0 and 1)
        of all shortest path calculations.
        Set to ``None`` to disable progress messages.

    Returns
    -------
    dm : numpy.ndarray
        Distance matrix of shape ``(n, n)``, where ``n`` is the number of
        nodes in the graph.
    """
    nNodes = G.number_of_nodes()
    dm = np.zeros((nNodes, nNodes))

    # Compute distances from a single point to everything else
    time_1 = time()
    flag_prev = 0
    for i in range(nNodes):
        dist_dict = dict(nx.shortest_path_length(G, source=i, weight=weight))

        # Write into the distance matrix
        for j in range(i + 1, nNodes):
            dm[i, j] = dist_dict[j]
            dm[j, i] = dist_dict[j]

        if progress is not None:
            flag_new = np.floor(i / (nNodes * progress))
            if flag_new > flag_prev:
                time_2 = time()

                percent = np.floor(100 * i / nNodes)
                dt = display_time(time_2 - time_1)
                print(f"{percent}%: {dt}")
                time_1 = time_2
                flag_prev = flag_new
    return dm


# -------------------------------------
# Graph generators
# -------------------------------------
# Create several graphs with a graph generator and put them in a cycle
# by joining their 0-th vertices
def cycle_of_generators_variable(generator, arglist):
    """
    Construct a cycle of graphs generated by the provided function.

    Create len(arglist) graphs with generator(*arglist[i]). Then, create a
    cycle graph and paste the 0-th vertex of each graph to a different node
    of the cycle.

    Parameters
    ----------
    generator : callable
        Function that generates a NetworkX graph.
    arglist : list of tuple
        Each tuple is unpacked and passed to ``generator`` as arguments.

    Returns
    -------
    G : networkx.Graph
        A set of graphs arranged in a cycle.
    """
    num_graphs = len(arglist)

    n_nodes = 0
    t_prev = 0
    for idx in range(num_graphs):
        # Create graph and update number of nodes
        G_i = generator(*arglist[idx])
        n_i = G_i.number_of_nodes()

        # Store G_i if we only have a single graph
        if idx == 0:
            G = G_i
            n_nodes += n_i
            continue

        # Otherwise, we join G_i and G
        mapping = {t: t + n_nodes for t in range(n_i)}
        G_i = nx.relabel_nodes(G_i, mapping)
        G = nx.compose(G, G_i)

        # Add an edge between G and G_i
        G.add_edge(t_prev, n_nodes)

        # Update markers
        t_prev = n_nodes
        n_nodes += n_i

    # Close the cycle
    G.add_edge(t_prev, 0)

    return G


def cycle_of_generators(num_graphs, generator, *args):
    """
    Create a cycle of graphs by repeatedly calling a generator with the same set of arguments.

    Parameters
    ----------
    num_graphs : int
        Number of graphs to create. Also the length of the resulting cycle.
    generator : callable
        Function that generates a NetworkX graph.
    *args : tuple
        Arguments passed to ``generator`` in each call.

    Returns
    -------
    G : networkx.Graph
        A set of ``num_graphs`` graphs arranged in a cycle.
    """
    arglist = [args] * num_graphs
    return cycle_of_generators_variable(generator, arglist)


def cycle_of_generators_fun(generator):
    """
    Return a convenience wrapper for `cycle_of_generators` with a fixed generator.

    Parameters
    ----------
    generator : callable
        Function that generates a NetworkX graph.

    Returns
    -------
    fun : callable
        Function that generates a cycle of graphs with arguments:
            - num_groups: length of the cycle of graphs
            - args: arguments to pass to the ``generator`` function.
    """

    def fun(num_graphs, *args):
        return cycle_of_generators(num_graphs, generator, *args)

    return fun


def nested_cycles(*args):
    """
    Create a nested cycle of cliques.

    Parameters
    ----------
    *args : int
        Sequence of integers defining the size of each cycle from
        outermost to innermost. The last argument is the size of
        the innermost cliques.

    Returns
    -------
    G : networkx.Graph
        The resulting nested cycle of cliques.
    """
    num_args = len(args)

    generator = nx.complete_graph
    for _ in range(1, num_args):
        generator = cycle_of_generators_fun(generator)

    return generator(*args)


# -- Unused generators --
# Creates a set of graphs with generator(arg) for arg in arglist
# then joins all of them at their 0-th vertex
def wedge_of_generators(generator, arglist):
    """
    Construct a wedge of graphs generated by the provided function.

    Create len(arglist) graphs with generator(*arglist[i]). Then, create a
    wedge of graphs by pasting all graphs at their 0-th vertex.

    Parameters
    ----------
    generator : callable
        Function that generates a NetworkX graph.
    arglist : list of tuple
        Each tuple is unpacked and passed to ``generator`` as arguments.

    Returns
    -------
    G : networkx.Graph
        A wedge of all the generated graphs.
    """
    n_graphs = len(arglist)
    n_nodes = 0

    for idx in range(n_graphs):
        # Create graph and update number of nodes
        G_i = generator(*arglist[idx])
        n_i = G_i.number_of_nodes()

        # Store G_i if we have a single graph
        if idx == 0:
            G = G_i
            n_nodes += n_i
            continue

        # Otherwise, we join G_i and G
        mapping = {t: t + n_nodes - 1 for t in range(1, n_i)}
        G_i = nx.relabel_nodes(G_i, mapping, copy=False)
        G = nx.compose(G, G_i)

        # Update number of nodes
        n_nodes += n_i

    return G


# Remove the generator argument from cycle_of_generators
def wedge_of_generators_fun(generator):
    """
    Return a convenience wrapper for `wedge_of_generators` with a fixed generator.

    Parameters
    ----------
    generator : callable
        Function that generates a NetworkX graph.

    Returns
    -------
    fun : callable
        Function that generates a wedge of graphs given a list of arguments
        ``arglist``.
    """

    def fun(arglist):
        return wedge_of_generators(generator, arglist)

    return fun


# -------------------------------------
# Plotting nested cycles
# -------------------------------------
def pos_cycle(n, R=1, c=[0, 0], t0=np.pi / 2):
    """
    Compute node positions for a cycle graph arranged on a circle.

    The result can be passed as the ``pos`` argument to the ``nx.draw``
    function when drawing a cycle graph.

    Parameters
    ----------
    n : int
        Number of nodes in the cycle.
    R : float, optional
        Radius of the circle (default is 1).
    c : array-like of float, optional
        Center coordinates of the circle (default is [0, 0]).
    t0 : float, optional
        Starting angle offset in radians (default is pi/2).

    Returns
    -------
    pos : numpy.ndarray
        Array of shape ``(n, 2)`` with x, y coordinates of each node.
    """
    # Draw a complete graph around a circle
    tt = t0 + np.linspace(0, 2 * np.pi, n + 1)
    tt = np.delete(tt, -1)

    xx = c[0] + R * np.cos(tt)
    yy = c[1] + R * np.sin(tt)

    pos = np.column_stack([xx, yy])
    return pos


def rotation_matrix(t):
    """
    Constructs 2D rotation matrix.

    Parameters
    ----------
    t : float
        Rotation angle in radians.

    Returns
    -------
    M : numpy.ndarray
        2x2 rotation matrix.
    """
    return np.array([[np.cos(t), -np.sin(t)], [np.sin(t), np.cos(t)]])


def pos_cycle_of_graphs(pos_list, R=4, t0=np.pi):
    """
    Calculate vertex positions for a cycle of graphs with positions given in pos_list.

    ``pos_list`` contains the default positions of the subgraphs. We translate
    and rotate those positions so that the 0-th vertices of the sugraphs form
    a cycle.
    The result can be passed as the ``pos`` argument to the ``nx.draw``
    function when drawing a cycle of graphs.

    Parameters
    ----------
    pos_list : list of numpy.ndarray
        List of position arrays of the subgraphs.
    R : float, optional
        Radius of the outer cycle (default is 4).
    t0 : float, optional
        Angular offset of the outer cycle in radians (default is pi).

    Returns
    -------
    pos_all : numpy.ndarray
        Array with x, y coordinates of each node.
    """
    n = len(pos_list)

    # Angles in the outer cycle
    tt = np.linspace(0, 2 * np.pi, n + 1)
    tt = np.delete(tt, -1)

    # Position of the outer cycle
    pos_out = pos_cycle(n, R=R)

    # Place each inner subgraph at a vertex of the outer cycle
    pos_all = np.zeros((0, 2))
    for idx in range(n):
        t = tt[idx]
        M = rotation_matrix(t + t0)
        dR = pos_out[idx]

        # I need to rotate and translate the position of the inner cycle
        pos_0 = pos_list[idx]
        pos_all = np.concatenate([pos_all, dR + pos_0 @ M.T], axis=0)

    return pos_all


def pos_cycle_uniform(n, pos_0, R=4, t0=np.pi):
    """
    Calculate vertex positions for a cycle of graphs by repeating a fixed position.

    The result can be passed as the ``pos`` argument to the ``nx.draw``
    function when drawing a cycle of graphs.

    Parameters
    ----------
    n : int
        Number of copies of the subgraph.
    pos_0 : numpy.ndarray
        Node positions for a single subgraph.
    R : float, optional
        Radius of the outer cycle (default is 4).
    t0 : float, optional
        Angular offset in radians (default is pi).

    Returns
    -------
    pos_all : numpy.ndarray
        Array with x, y coordinates of each node.
    """
    return pos_cycle_of_graphs([pos_0] * n, R=R, t0=t0)


# Positions for a nested cycle of graphs
def pos_nested_cycles(*args, scale=4):
    """
    Calculate vertex positions for a nested cycle of cliques.

    The result can be passed as the ``pos`` argument to the ``nx.draw``
    function when drawing a nested cycle of cliques.

    Parameters
    ----------
    *args : int
        Sequence of integers defining the size of each cycle from
        outermost to innermost. The last argument is the size of
        the innermost cliques.
    scale : float, optional
        Scaling factor between levels (default is 4).

    Returns
    -------
    pos_new : numpy.ndarray
        Array with x, y coordinates of each node.
    """
    num_args = len(args)

    # It's more convenient for the user to pass arguments from
    # outer cycle to inner cycle. However, for us, it's easier to
    # consume the arguments from inner to outer
    args = args[::-1]

    # Recursively compute positions of nested cycles
    pos_new = pos_cycle(args[0])
    for idx in range(1, num_args):
        pos_old = pos_new
        pos_new = pos_cycle_uniform(args[idx], pos_old, R=scale**idx)

    return pos_new
